# This file was fully generated by ChatGPT
"""
Food Delivery Data Simulator
Single-file implementation matching the requested project structure.

Структура внутри файла разделена комментариями на модули:
 - config
 - entities
 - utils
 - generators
 - simulation
 - main

Запуск: python food_delivery_simulator.py

В результате будут созданы CSV в ./output

Примечание: для уменьшения времени генерации по умолчанию можно уменьшить
AVG_ORDERS_PER_DAY в блоке CONFIG или временной интервал.
"""

# ---------------------------
# CONFIG (config.py)
# ---------------------------
from __future__ import annotations

import os
import random
import uuid
from dataclasses import dataclass
from datetime import datetime, timedelta, time
from typing import List, Optional, Dict, Any

import numpy as np
from faker import Faker
import pandas as pd

RANDOM_SEED = 42
START_DATE = "2023-01-01"
END_DATE = "2026-12-31"

RESTAURANTS_NUMBER = 100
USERS_NUMBER = 10000
COURIERS_NUMBER = 500
PROMO_NUMBER = 50

AVG_ORDERS_PER_DAY = 3000
ORDER_PROB_BY_PLATFORM = {"ios": 0.4, "android": 0.5, "web": 0.1}

PROBABILITIES = {
    "generate_order": 0.6,
    "generate_user": 0.1,
    "generate_restaurant": 0.02,
    "generate_courier": 0.02,
    "generate_promo": 0.01,
    "generate_session": 0.25,
}

# Активность пользователей по часам (относительные веса внутри окна)
HOURLY_ACTIVITY = {
    "00-02": 0.2,
    "03-09": 0.05,
    "10-16": 0.7,
    "17-22": 1.0,
    "23-24": 0.4,
}

# Модель ретеншена (вероятность вернуться N-го дня после регистрации)
RETENTION_MODEL = {1: 0.6, 2: 0.4, 3: 0.3, 4: 0.25, 5: 0.2, 6: 0.15, 7: 0.1}

OUTPUT_DIR = "output"

# Ensure reproducible
random.seed(RANDOM_SEED)
np.random.seed(RANDOM_SEED)
faker = Faker()
Faker.seed(RANDOM_SEED)

# ---------------------------
# ENTITIES (entities.py)
# ---------------------------


@dataclass
class Restaurant:
    id: str
    name: str
    city: str
    cuisine_type: str
    rating: float
    work_start_time: time
    work_end_time: time
    is_24h: bool

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "name": self.name,
            "city": self.city,
            "cuisine_type": self.cuisine_type,
            "rating": round(self.rating, 2),
            "work_start_time": self.work_start_time.strftime("%H:%M"),
            "work_end_time": self.work_end_time.strftime("%H:%M"),
            "is_24h": int(self.is_24h),
        }


@dataclass
class User:
    id: str
    name: str
    city: str
    platform: str
    gender: str
    birth_date: datetime
    registered_at: datetime

    def to_dict(self):
        return {
            "id": self.id,
            "name": self.name,
            "city": self.city,
            "platform": self.platform,
            "gender": self.gender,
            "birth_date": self.birth_date.date().isoformat(),
            "registered_at": self.registered_at.isoformat(),
        }


@dataclass
class Courier:
    id: str
    name: str
    city: str
    transport: str
    rating: float

    def to_dict(self):
        return {
            "id": self.id,
            "name": self.name,
            "city": self.city,
            "transport": self.transport,
            "rating": round(self.rating, 2),
        }


@dataclass
class Promocode:
    id: str
    code: str
    discount_pct: float
    start_dt: datetime
    end_dt: datetime

    def to_dict(self):
        return {
            "id": self.id,
            "code": self.code,
            "discount_pct": round(self.discount_pct, 2),
            "start_dt": self.start_dt.isoformat(),
            "end_dt": self.end_dt.isoformat(),
        }


@dataclass
class Order:
    id: str
    created_dt: datetime
    accepted_dt: Optional[datetime]
    delivered_dt: Optional[datetime]
    user_id: str
    restaurant_id: str
    courier_id: Optional[str]
    status: str
    platform: str
    total_amount: float
    payment_method: str
    promo_id: Optional[str]

    def to_dict(self):
        return {
            "id": self.id,
            "created_dt": self.created_dt.isoformat(),
            "accepted_dt": self.accepted_dt.isoformat() if self.accepted_dt else None,
            "delivered_dt": (
                self.delivered_dt.isoformat() if self.delivered_dt else None
            ),
            "user_id": self.user_id,
            "restaurant_id": self.restaurant_id,
            "courier_id": self.courier_id,
            "status": self.status,
            "platform": self.platform,
            "total_amount": round(self.total_amount, 2),
            "payment_method": self.payment_method,
            "promo_id": self.promo_id,
        }


@dataclass
class Session:
    id: str
    user_id: str
    started_at: datetime
    ended_at: datetime
    actions: int
    platform: str

    def to_dict(self):
        return {
            "id": self.id,
            "user_id": self.user_id,
            "started_at": self.started_at.isoformat(),
            "ended_at": self.ended_at.isoformat(),
            "actions": self.actions,
            "platform": self.platform,
        }


# ---------------------------
# UTILS (utils.py)
# ---------------------------


def ensure_output_dir():
    os.makedirs(OUTPUT_DIR, exist_ok=True)


def daterange(start_date: datetime, end_date: datetime):
    cur = start_date
    while cur.date() <= end_date.date():
        yield cur
        cur += timedelta(days=1)


def parse_timewindow(window_label: str):
    """Парсит строки вида '10-16' и возвращает (start_hour, end_hour)."""
    a, b = window_label.split("-")
    return int(a), int(b)


def weighted_hour_choices_for_day(day: datetime) -> List[int]:
    """Возвращает список часов 0..23 с весами, учитывая HOURLY_ACTIVITY и день недели модификатор.
    Использует HOURLY_ACTIVITY из CONFIG.
    """
    weights = [0.0] * 24
    # map windows
    for window, w in HOURLY_ACTIVITY.items():
        start_h, end_h = parse_timewindow(window)
        # end is inclusive of hour-1; if '23-24' treat end_h as 24
        for h in range(start_h, min(end_h, 24)):
            weights[h] = max(weights[h], w)
    # modifiers by weekday
    weekday = day.weekday()  # Monday=0
    modifier = 1.0
    if weekday == 4 or weekday == 5:  # Friday or Saturday
        modifier *= 1.2
    if weekday == 0:  # Monday
        modifier *= 0.8
    weights = [w * modifier for w in weights]

    # normalize to non-zero
    if sum(weights) == 0:
        weights = [1.0] * 24
    return weights


def next_event_time(current_time: datetime) -> datetime:
    """Возвращает случайное смещение времени, взвешенное по HOURLY_ACTIVITY.

    Алгоритм: выбираем следующий час с учётом весов для дня current_time.date(),
    затем добавляем случайную минуту/секунду внутри часа.
    """
    # choose hour for same day with weights
    weights = weighted_hour_choices_for_day(current_time)
    hour = int(np.random.choice(np.arange(24), p=np.array(weights) / sum(weights)))
    minute = random.randint(0, 59)
    second = random.randint(0, 59)
    next_dt = current_time.replace(hour=hour, minute=minute, second=second)
    # if chosen hour earlier than now -> move to next day
    if next_dt <= current_time:
        next_dt = next_dt + timedelta(days=1)
    return next_dt


# ---------------------------
# GENERATORS (generators.py)
# ---------------------------

CUISINES = [
    "Italian",
    "Chinese",
    "Japanese",
    "Fast Food",
    "Indian",
    "French",
    "American",
    "Mexican",
    "Mediterranean",
]
PLATFORMS = list(ORDER_PROB_BY_PLATFORM.keys())
GENDERS = ["male", "female", "other"]
TRANSPORTS = ["bike", "car", "walk"]
PAYMENT_METHODS = ["card", "cash", "apple_pay", "google_pay"]


def generate_restaurant(t: datetime) -> Restaurant:
    """Создать ресторан."""
    rid = str(uuid.uuid4())
    name = faker.company() + " " + random.choice(["Kitchen", "Bistro", "Grill", "Cafe"])
    city = faker.city()
    cuisine = random.choice(CUISINES)
    rating = random.uniform(3.5, 4.9)
    is_24h = random.random() < 0.2
    if is_24h:
        start = time(0, 0)
        end = time(23, 59)
    else:
        # random window between 9:00 and 23:00
        start_h = random.randint(8, 12)
        end_h = random.randint(20, 23)
        start = time(start_h, 0)
        end = time(end_h, 0)
    return Restaurant(rid, name, city, cuisine, rating, start, end, is_24h)


def generate_user(t: datetime) -> User:
    """Создать пользователя. registered_at == t."""
    uid = str(uuid.uuid4())
    name = faker.name()
    city = faker.city()
    platform = random.choices(
        PLATFORMS, weights=[ORDER_PROB_BY_PLATFORM[p] for p in PLATFORMS]
    )[0]
    gender = random.choice(GENDERS)
    # birth date between 18 and 70
    age = random.randint(18, 70)
    birth = t - timedelta(days=365 * age + random.randint(0, 365))
    registered_at = t
    return User(uid, name, city, platform, gender, birth, registered_at)


def generate_courier(t: datetime) -> Courier:
    cid = str(uuid.uuid4())
    name = faker.name()
    city = faker.city()
    transport = random.choice(TRANSPORTS)
    rating = random.uniform(3.0, 5.0)
    return Courier(cid, name, city, transport, rating)


def generate_promo(t: datetime) -> Promocode:
    pid = str(uuid.uuid4())
    code = faker.lexify(text="PROMO????")
    discount = random.choice([5, 7, 10, 15, 20, 25])
    start = t
    duration_days = random.randint(3, 30)
    end = start + timedelta(days=duration_days)
    return Promocode(pid, code, discount, start, end)


def generate_order(
    t: datetime,
    users: List[User],
    restaurants: List[Restaurant],
    couriers: List[Courier],
    promos: List[Promocode],
) -> Order:
    """Создает заказ, учитывая активность по часам и рабочее время ресторана."""
    oid = str(uuid.uuid4())
    # choose user weighted by registration recency (newer users slightly more active)
    user = random.choice(users)
    # pick platform from user
    platform = user.platform
    # choose restaurant in same city with fallback
    same_city_restaurants = [r for r in restaurants if r.city == user.city]
    restaurant = (
        random.choice(same_city_restaurants)
        if same_city_restaurants
        else random.choice(restaurants)
    )

    # choose created_dt respecting restaurant hours (unless 24h)
    attempts = 0
    created_dt = t
    while True:
        created_dt = next_event_time(t)
        # check if in restaurant working hours
        if restaurant.is_24h:
            break
        ct = created_dt.time()
        if restaurant.work_start_time <= ct <= restaurant.work_end_time:
            break
        attempts += 1
        if attempts > 5:
            # give up and allow (real-world: may be pre-order)
            break

    # accepted and delivered
    accepted_dt = created_dt + timedelta(seconds=random.randint(60, 5 * 60))
    delivered_dt = accepted_dt + timedelta(seconds=random.randint(15 * 60, 60 * 60))

    # status
    status = random.choices(
        ["delivered", "cancelled", "failed"], weights=[0.9, 0.08, 0.02]
    )[0]
    # courier assigned only if delivered or cancelled after acceptance
    courier_id = None
    if status == "delivered" or (status == "cancelled" and random.random() < 0.5):
        courier = random.choice(couriers)
        courier_id = courier.id

    # amount depends on cuisine and rating
    base = {
        "Fast Food": 8,
        "Italian": 18,
        "Chinese": 15,
        "Japanese": 20,
        "Indian": 14,
        "French": 22,
        "American": 16,
        "Mexican": 13,
        "Mediterranean": 17,
    }
    avg = base.get(restaurant.cuisine_type, 15)
    # variation by restaurant rating
    total = np.random.normal(loc=avg, scale=avg * 0.3)
    total = max(3.0, float(total))

    # promo
    applicable_promos = [p for p in promos if p.start_dt <= created_dt <= p.end_dt]
    promo = (
        random.choice(applicable_promos)
        if applicable_promos and random.random() < 0.05
        else None
    )
    if promo:
        total = total * (1 - promo.discount_pct / 100.0)

    payment_method = random.choice(PAYMENT_METHODS)

    # ensure chronology
    if not (created_dt <= accepted_dt <= delivered_dt):
        accepted_dt = created_dt + timedelta(seconds=60)
        delivered_dt = accepted_dt + timedelta(seconds=20 * 60)

    return Order(
        oid,
        created_dt,
        accepted_dt if status != "failed" else None,
        delivered_dt if status == "delivered" else None,
        user.id,
        restaurant.id,
        courier_id,
        status,
        platform,
        total,
        payment_method,
        promo.id if promo else None,
    )


def generate_session(t: datetime, user: User) -> Session:
    sid = str(uuid.uuid4())
    started_at = t
    duration_min = random.randint(1, 60)
    ended_at = started_at + timedelta(minutes=duration_min)
    actions = random.randint(1, 50)
    return Session(sid, user.id, started_at, ended_at, actions, user.platform)


# ---------------------------
# SIMULATION (simulation.py)
# ---------------------------


class Simulator:
    def __init__(self):
        self.restaurants: List[Restaurant] = []
        self.users: List[User] = []
        self.couriers: List[Courier] = []
        self.promos: List[Promocode] = []
        self.orders: List[Order] = []
        self.sessions: List[Session] = []

    def initialize_base(self):
        # initial seeds of entities according to CONFIG
        now = datetime.fromisoformat(START_DATE)
        for _ in range(RESTAURANTS_NUMBER):
            self.restaurants.append(generate_restaurant(now))
        for _ in range(USERS_NUMBER):
            # spread registration across first 30 days
            reg_dt = now + timedelta(
                days=random.randint(0, 29), seconds=random.randint(0, 86400)
            )
            self.users.append(generate_user(reg_dt))
        for _ in range(COURIERS_NUMBER):
            self.couriers.append(generate_courier(now))
        for _ in range(PROMO_NUMBER):
            promo_dt = now + timedelta(days=random.randint(0, 365))
            self.promos.append(generate_promo(promo_dt))

    def run(self):
        ensure_output_dir()
        start = datetime.fromisoformat(START_DATE)
        end = datetime.fromisoformat(END_DATE)
        current = start

        self.initialize_base()

        # For retention: track user last activity day and registration day
        user_registration_days: Dict[str, datetime] = {
            u.id: u.registered_at for u in self.users
        }

        # iterate days
        total_days = (end.date() - start.date()).days + 1
        expected_total_orders = int(AVG_ORDERS_PER_DAY * total_days)

        print(f"Simulation from {START_DATE} to {END_DATE} ({total_days} days)")
        print(f"Expecting ~{expected_total_orders} orders")

        while current.date() <= end.date():
            # determine number of events today roughly
            daily_orders = np.random.poisson(AVG_ORDERS_PER_DAY)
            # for speed: cap excessive
            daily_orders = max(0, daily_orders)

            # create sessions and orders distributed by hour weights
            # seed a day's starting time
            day_time = current.replace(hour=0, minute=0, second=0)

            # Generate some new users/restaurants/couriers/promos based on probabilities
            if random.random() < PROBABILITIES["generate_user"]:
                self.users.append(
                    generate_user(
                        day_time + timedelta(seconds=random.randint(0, 86400))
                    )
                )
            if random.random() < PROBABILITIES["generate_restaurant"]:
                self.restaurants.append(generate_restaurant(day_time))
            if random.random() < PROBABILITIES["generate_courier"]:
                self.couriers.append(generate_courier(day_time))
            if random.random() < PROBABILITIES["generate_promo"]:
                self.promos.append(generate_promo(day_time))

            # Sessions: some fraction of users open app
            session_users = random.sample(
                self.users, k=min(len(self.users), int(len(self.users) * 0.02) + 1)
            )
            for u in session_users:
                # choose if session happens based on retention model if recent registrant
                self.sessions.append(
                    generate_session(
                        day_time + timedelta(seconds=random.randint(0, 86400)), u
                    )
                )

            # Orders generation
            for _ in range(daily_orders):
                if random.random() < PROBABILITIES["generate_order"]:
                    # pick timestamp for order
                    order_time = next_event_time(
                        day_time + timedelta(seconds=random.randint(0, 86400))
                    )
                    order = generate_order(
                        order_time,
                        self.users,
                        self.restaurants,
                        self.couriers,
                        self.promos,
                    )
                    self.orders.append(order)

            # Retention model: users coming back after registration
            for u in self.users:
                days_since_reg = (current.date() - u.registered_at.date()).days
                if days_since_reg < 0 or days_since_reg > max(RETENTION_MODEL.keys()):
                    continue
                prob = RETENTION_MODEL.get(days_since_reg, 0)
                if random.random() < prob:
                    # user opens session
                    s = generate_session(
                        day_time + timedelta(seconds=random.randint(0, 86400)), u
                    )
                    self.sessions.append(s)
                    # may place order with probability depending on time & platform
                    p_order = 0.02
                    if u.platform == "ios":
                        p_order *= 1.05
                    if u.platform == "android":
                        p_order *= 1.02
                    # peak hours boost
                    hour = s.started_at.hour
                    hourly_weights = weighted_hour_choices_for_day(s.started_at)
                    peak_factor = hourly_weights[hour] / (
                        sum(hourly_weights) / 24 + 1e-9
                    )
                    if random.random() < p_order * peak_factor:
                        ordt = s.started_at + timedelta(minutes=random.randint(1, 120))
                        o = generate_order(
                            ordt, [u], self.restaurants, self.couriers, self.promos
                        )
                        self.orders.append(o)

            # advance day
            current = current + timedelta(days=1)

        # after simulation, export
        self.export_all()

    def export_all(self):
        # Convert dataclass lists to DataFrames and save to CSV
        def save_list(items, filename):
            rows = [getattr(i, "to_dict")() for i in items]
            df = pd.DataFrame(rows)
            path = os.path.join(OUTPUT_DIR, filename)
            df.to_csv(path, index=False)
            print(f"Saved {len(df)} rows to {path}")
            return df

        df_users = save_list(self.users, "users.csv")
        df_restaurants = save_list(self.restaurants, "restaurants.csv")
        df_couriers = save_list(self.couriers, "couriers.csv")
        df_promos = save_list(self.promos, "promos.csv")
        df_orders = save_list(self.orders, "orders.csv")
        df_sessions = save_list(self.sessions, "sessions.csv")

        # basic summary
        try:
            avg_check = df_orders["total_amount"].mean()
            print("\nSummary:")
            print(f"Orders: {len(df_orders)}, Avg check: {avg_check:.2f}")
            print(
                f"Users: {len(df_users)}, Restaurants: {len(df_restaurants)}, Couriers: {len(df_couriers)}"
            )
        except Exception:
            pass


# ---------------------------
# MAIN (main.py)
# ---------------------------

if __name__ == "__main__":
    sim = Simulator()
    sim.run()
